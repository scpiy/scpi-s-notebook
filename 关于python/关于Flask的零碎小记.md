# 关于Flask的零碎小记

#### 第五章：用户登录

------

`current_user`什么时候可以使用呢？

答：当你从`flask_login`导入`current_user`之后他就可以使用了。

------



#### 第六章：个人主页与头像

`@app.befor_request`用于定义一个在所有视图函数被调用之前运行的一个小函数，用于执行某种特定个很小的功能。比如更新用户的最后上线时间。

> 考虑在引用`current_user`时，flask-login将调用用户加载函数，该函数会执行一个数据库查询并将目标用户添加到数据库会话中。

也就是说，`db.session.add(user)`在使用`current_user`的时候已经被执行了。

#### 第七章： 错误处理

调试模式可以启用重载器，这样我就不必每次对数据文件进行更改后重启应用了。但对我来说用处似乎不大。

视图函数应该至少拥有两个返回值，第一个是渲染出的html界面，另一个是状态码。默认情况下状态码为200(成功响应)。

回话回滚具体是个什么东西我不清楚，但它的功能大概是让数据库回到上一个"健康"的状态吧。

500错误应该不仅仅会由数据库错误引起，这个回话回滚应该不会误伤"健康"状态下的数据库。也就是说，这个东西应该只是把数据库回到上一次`db.session.commit()`的状态，把从上一次提交之后所有的类似`db.session.add()`或是其他的什么操作删除吧。如果上一次提交之后什么都没有做，那么这个函数应该也是什么都不会做的。

#### 第八章：粉丝

`flask-SQLAlchemy`提供对多对多结构的高级抽象，也就是在`db.relationship`函数中使用`secondary`，用户不必手动构建多对多关系结构。

未关联到模型类的表格的字段的访问方法不再是简单地访问表单类的成员，而是使用类似`followers.c.flower_id`这样的东西。

`flask-SQLAlchemy`真的很方便诶，抽象了底部细节，只要调用高层的接口，就可以实现自己想要的功能。

---

```python
def is_following(self, user):
        return self.followed.filter(
            followers.c.followed_id == user.id).count() > 0
```

关于这个函数，教程上说的我看得有点迷迷糊糊的，大概是有点困了吧。总之也算是自己想了想，用自己的语言描述一下吧。

`self.followerd`执行第一次查询，查询`followers`关联表中**左侧`follower_id`等于`self.id`**的记录并返回，`filter(followers.c.followed_id == user.id)`执行第二次查询，查询第一次查询结果中**右侧`followed_id`等于`user.id`**的记录。

或者这么想一下，对于`followers`表，想要查询A用户是否关注了B用户，首先需要在这个表格中寻找所有**追随者**为A用户的记录，然后在查询到的结果中寻找**被追随者**为B用户的记录。

原文：

> `is_following()`方法发出一个关于`followed`关系的查询来检查两个用户之间的关系是否已经存在。 你已经看到过我使用SQLAlchemy查询对象的`filter_by()`方法，例如，查找给定用户名的用户。 我在这里使用的`filter()`方法很类似，但是更加偏向底层，因为它可以包含任意的过滤条件，而不像`filter_by()`，它只能检查是否等于一个常量值。 我在`is_following()`中使用的过滤条件是，查找关联表中左侧外键设置为`self`用户且右侧设置为`user`参数的数据行。 查询以`count()`方法结束，返回结果的数量。 这个查询的结果是`0`或`1`，因此检查计数是1还是大于0实际上是相等的。 至于其他的查询结束符`all()`和`first()`，你已经看到我使用过了。

~~逻辑上，这条记录要么有，要么没有，没必要存在两条相同的记录说A关注了B。恩。~~

---

当开始思考如何在用户主页展示用户所关注的人的动态时，我第一时间想到的是：使用用户的`followerd`字段得到用户关注的所有人，再得到所有人的动态，再按时间排序。这是我第一时间想到的方法，也是教程的作者第一时间就否定的方法。鉴于他的理由过于充分，我实在无法反驳这的确很低效的事实。

因材施教，谁适合干什么谁不适合干什么一定要清楚，虽然逻辑上似乎"先获取用户在获取用户动态"与"先获取动态再筛选出所需用户动态"没有区别，但是到实践中差距还是蛮大的。前者不仅要多次调用借口增加函数调用开销，而且所需的用户动态只是查询结果的很小一部分，浪费了很多资源。但是讲真后者所需要的开销也绝非小可，当用户量较多时，对所有用户动态进行查询大概会是一个可怕的工作。但是数据库似乎很擅长这种工作，所以也说不定呢。

```
class User(db.Model):
    #...
    def followed_posts(self):
        return Post.query.join(
            followers, (followers.c.followed_id == Post.user_id)).filter(
                followers.c.follower_id == self.id).order_by(
                    Post.timestamp.desc())
```

嗯，这段代码，看懂之后就很好理解，但刚开始看的时候稍微有点一头雾水诶，是不是太困了啊。总之还是做了下笔记，重点说一下`join`这个方法。

`join`大概是数据库表格的方法，作用是筛选出数据库表格中符合要求的记录并作为一个新的表格返回，但这个新的表格的类型依旧没有变化，也就是说，如果你在`Post`表格上调用`join`方法，返回的依旧是`Post`表格，为什么要强调一下呢？因为教程的作者的原话中提到了"创建一个新的表格，新的表格为`Post`与`followers`的集合。"嘛，作者说的的确挺好的，而且大概还涉及到了`join`的底层细节，但或许没必要这样说也可以，之后作者又说`join`返回的是`Post`，我刚开始还有点晕呢。

`join`至少有两个参数，第一个参数是一个表格，第二个参数是一个规则，符合该规则的记录将被留下，否则会被筛选出去。~~写到这里我稍微有点疑惑，作者之前提到过`filter`方法只接受一个常数，这是否是在这里不使用`filter`的理由？当想要筛选出符合某项规则且该规则并非简单地等于一个常数(比如这里，筛选规则是某个字段的值等于给定集合中某个值)时，是否就应该使用join方法，而且该方法是否只能用于表单也可以研究一下，但这是之后的事了。~~

恩，这样就行了。

~~现阶段没必要深究，我还只是一个初学者，先掌握大体结构为重。~~

---

